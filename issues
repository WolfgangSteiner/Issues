#!/usr/bin/env ruby
# encoding: utf-8 
#======================================================================================================================#

require 'rubygems'
require 'fattr'
require 'SecureRandom'
require 'trollop'
require 'terminfo'
require 'tempfile'
require 'yaml'

#YAML::ENGINE.yamler = 'psych'

#======================================================================================================================#

def terminal_width
  TermInfo.screen_size[1]
end


#----------------------------------------------------------------------------------------------------------------------#

def separator(char='=')
  '#' + (char * (terminal_width - 2)) + '#'
end  


#----------------------------------------------------------------------------------------------------------------------#

def small_separator
  separator ('-')
end  


#----------------------------------------------------------------------------------------------------------------------#

def comment(comment)
  pad_string("\# #{comment}", "#", terminal_width)
end


#----------------------------------------------------------------------------------------------------------------------#

def pad_string(a_string, a_suffix, a_width)
  a_suffix.length ? a_string + " " * (a_width - a_string.length - a_suffix.length) + a_suffix : a_string.dup
end


#======================================================================================================================#

class Issue
  fattr :id, :date, :type, :title, :description, :status


#----------------------------------------------------------------------------------------------------------------------#  

  def self.createNewIssue(title, type="bug")
    newIssue = Issue.new
    newIssue.id = SecureRandom.hex.force_encoding("UTF-8")
    newIssue.date = Time.new
    newIssue.title = title
    newIssue.status = "open"
    newIssue.type = type
    newIssue
  end


#----------------------------------------------------------------------------------------------------------------------#  

  def copy_from(a_issue)
    self.class.fattrs.each do |a|
      a_issue.send(a) && self.send(a, a_issue.send(a).dup)
    end
  end  
      
#----------------------------------------------------------------------------------------------------------------------#  
  
  def format_title(prefix, only_first_line_prefix=false, suffix='')
    the_suffix = suffix.length ? " " + suffix : ""
    text_width = terminal_width - 1 - the_suffix.length
    title_array = @title.split(" ")
    result = []
    current_line = prefix.dup
    current_prefix = only_first_line_prefix && " " * prefix.length || prefix.dup
    
    title_array.each do |w|
      (current_line.length + w.length + 1 > text_width) \
        && result << pad_string(current_line, suffix, terminal_width) \
        && current_line = current_prefix.dup
      current_line << " " << w
    end
    
    current_line.length > current_prefix.length && result << pad_string(current_line, suffix, terminal_width)
    result.join("\n")
  end


#----------------------------------------------------------------------------------------------------------------------#  
  
  def format_verbose
    puts separator
    puts comment("#{@id[0,6]} #{@date.to_s[0,10]} #{@type.capitalize} (#{@status})")
    puts format_title("#", false, "#")
    
    if @description
      puts small_separator
      
      @description.split("\n").each do |l|
        puts pad_string("# #{l}", "#", terminal_width)
      end
    end
    
    puts separator
    puts
    puts
  end


#----------------------------------------------------------------------------------------------------------------------#

  def format_list
    puts format_title("#{short_id} (#{@type[0,1].capitalize})", true)
  end


#----------------------------------------------------------------------------------------------------------------------#  

  def edit_description
    file = Tempfile.new('issues')
    file.write(@description)
    file.close
    system("$EDITOR #{file.path}")

    file.open
    new_description = file.read

    puts new_description

    if new_description != @description
      @description = new_description.dup
      return true
    end
    
    return false
  end

#----------------------------------------------------------------------------------------------------------------------#  

  def edit_all
    edit_file = file = Tempfile.new('issues')
    file.write(self.to_yaml)
    file.close
    
    system("$EDITOR #{file.path}")

    file.open
    
    if (file.read != self.to_yaml)
      new_issue = YAML::load_file(file.path)
      self.copy_from(new_issue)
      return true
    end 
    
    return false
  end


#----------------------------------------------------------------------------------------------------------------------#  

  def short_id
    @id[0,6]
  end
    
end


#======================================================================================================================#
#                                                   Main Program Logic
#======================================================================================================================#

class IssuesDb
  fattr :issues_array
  
#----------------------------------------------------------------------------------------------------------------------#

  def initialize(database_file)
    @database_file = database_file
    @issues_array = FileTest.exists?(database_file) && YAML.load_file(database_file) || []
  end
  

#----------------------------------------------------------------------------------------------------------------------#

  def select_issue(issue_id)
    find_issue = lambda {|i| i.id.start_with?(issue_id) && i.status == "open"}
  
    num_issues = @issues_array.count(&find_issue)
    if num_issues == 1
      issue_index = @issues_array.index(&find_issue)
      return @issues_array[issue_index]

    elsif num_issues > 1
      puts "Found more than one open issues that match id #{issue_id}:"
      @issues_array.each{|i| find_issue.call(i) && puts("#{i.id} #{i.title}")}
      exit
    
    else
      puts "Error: No open issue found with id #{issue_id}"
    end

    nil
  end  


#----------------------------------------------------------------------------------------------------------------------#

  def save_db()
    FileTest.exists?('.issues') || Dir.mkdir('.issues')
    File.open(@database_file, 'w' ) { |out| YAML.dump(@issues_array, out) }
  end
  

#----------------------------------------------------------------------------------------------------------------------#

  def create_issue(opts)
    type = opts[:improvement] ? "improvement" : opts[:task] ? "task" : "bug"
    new_issue = Issue.createNewIssue(opts[:title], type)
    @issues_array << new_issue
    save_db()  
    puts "Created issue #{new_issue.short_id} #{new_issue.title}"
  end


#----------------------------------------------------------------------------------------------------------------------#

  def list_issues(opts)
    list_proc = opts[:verbose] ? "format_verbose" : "format_list"
    @issues_array.each {|issue| issue.method(list_proc).call if issue.status == 'open' }
  end


#----------------------------------------------------------------------------------------------------------------------#

  def resolve_issues(opts)
    resolved_issue = select_issue(opts[:issue_id])
    resolved_issue.status = "resolved"
    message = "Resolved issue #{resolved_issue.short_id} #{resolved_issue.title}"
    save_db()
    opts[:commit] && exec("git commit -a -m \"#{message}\"")
  end


#----------------------------------------------------------------------------------------------------------------------#

  def edit_issue(opts)
    issue = select_issue(opts[:issue_id])
  
    did_change_issue = false
  
    if (opts[:description])
      did_change_issue = issue.edit_description
    else
      did_change_issue = issue.edit_all
    end
   
    did_change_issue && save_db()
  end

#----------------------------------------------------------------------------------------------------------------------#

end


#======================================================================================================================#
# Command Line Parsing
#======================================================================================================================#

EXECUTABLE_NAME=File.basename($0)
DATABASE_NAME= ".issues/" << EXECUTABLE_NAME << ".yaml"

SUB_COMMANDS = %w(list create resolve edit)
global_opts = Trollop::options do
  banner "issue.rb: lightweight issue management"
  opt :dry_run, "Don't actually do anything", :short => "-n"
  stop_on SUB_COMMANDS
end



cmd = ARGV.shift # get the subcommand
cmd ||= 'list'

cmd_opts = {}

if cmd == 'list'
  cmd_opts = 
    Trollop::options do
      opt :all, "list all issues"
      opt :newest, "list newest issues first"
      opt :oldest, "list oldest issues first"
      opt :verbose, "verbose list of issues", :short => 'v'
    end
elsif cmd == "create"
  cmd_opts = 
    Trollop::options do
      opt :bug, "create a bug", :short => 'b'
      opt :improvement, "create an improvement", :short => 'i'
      opt :task, "create a task", :short => 't'
    end
  cmd_opts[:title] = ARGV.shift || Trollop::die( "Please enter a title for the new issue!")
elsif cmd == "resolve"
  cmd_opts = 
    Trollop::options do
      opt :commit, "do a git commit", :short => 'c'
    end  
  cmd_opts[:issue_id] = ARGV.shift || Trollop::die( "Please enter an issue id!")
elsif cmd == "edit"
  cmd_opts = 
    Trollop::options do
      opt :description, "edit the issue description", :short => 'd'
      opt :todos, "edit the issue todo list", :short => 't'
    end      
  cmd_opts[:issue_id] = ARGV.shift || Trollop::die( "Please enter an issue id!")
else
  Trollop::die "unknown command #{cmd.inspect}"
end


#======================================================================================================================#
#                                                         Main
#======================================================================================================================#

Issues = IssuesDb.new(DATABASE_NAME)

case cmd
  when "create" 
    Issues.create_issue(cmd_opts)
  when "list" 
    Issues.list_issues(cmd_opts)
  when "resolve" 
    Issues.resolve_issues(cmd_opts)
  when "edit"
    Issues.edit_issue(cmd_opts)
end


#======================================================================================================================#

