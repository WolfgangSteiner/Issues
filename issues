#!/usr/bin/env ruby
# encoding: utf-8 
#======================================================================================================================#

require 'rubygems'
require 'SecureRandom'
require 'trollop'
require 'terminfo'
require 'yaml'

YAML::ENGINE.yamler = 'syck'

#======================================================================================================================#

def separator
  termwidth = TermInfo.screen_size[1]
  '#' + ('=' * (termwidth - 2)) + '#'
end  


#----------------------------------------------------------------------------------------------------------------------#

def comment(comment)
  "\# #{comment}"
end


#----------------------------------------------------------------------------------------------------------------------#


class Issue
  attr_accessor :id, :date, :type, :title, :description, :status

  def self.createNewIssue(title, type="bug")
    newIssue = Issue.new
    newIssue.id = "#{SecureRandom.hex.to_s}"
    newIssue.date = Time.new
    newIssue.title = title
    newIssue.status = "open"
    newIssue.type = type
    newIssue
  end
  
  def format_verbose
    puts separator
    puts comment("#{@id[0,6]} #{@date.to_s[0,10]} #{@type.capitalize} (#{@status})")
    puts comment(@title)
    puts separator
  end

  def format_list
    puts "#{@id[0,6]} #{@title}"
  end
  
  def short_id
    @id[0,6]
  end
    
end


#----------------------------------------------------------------------------------------------------------------------#

def create_issue(opts, issues)
  type = opts[:improvement] ? "improvement" : opts[:task] ? "task" : "bug"
  new_issue = Issue.createNewIssue(opts[:title], type)
  issues << new_issue
  
  puts "Created issue #{new_issue.short_id} #{new_issue.title}"
end


#----------------------------------------------------------------------------------------------------------------------#

def list_issues(opts, issues)
  list_proc = opts[:verbose] ? "format_verbose" : "format_list"
  issues.each {|issue| issue.method(list_proc).call if issue.status == 'open' }
end


#----------------------------------------------------------------------------------------------------------------------#

def resolve_issues(opts, issues)
  find_issue = lambda {|i| i.id.start_with?(opts[:issue_id]) && i.status == "open"}
  
  num_issues = issues.count(&find_issue)
  if num_issues == 1
    issue_index = issues.index(&find_issue)
    resolved_issue = issues[issue_index]
    resolved_issue.status = "resolved"
    puts "Resolved issue #{resolved_issue.short_id} #{resolved_issue.title}"
  elsif num_issues > 1
    puts "Found more than one open issues that match id #{opts[:issue_id]}:"
    issues.each{|i| find_issue.call(i) && puts("#{i.id} #{i.title}")}
    exit
  else
    puts "Error: No open issue found with id #{opts[:issue_id]}"
  end
end


#======================================================================================================================#
# Command Line Parsing
#======================================================================================================================#

EXECUTABLE_NAME=File.basename($0)
DATABASE_NAME= ".issues/" << EXECUTABLE_NAME << ".yaml"

SUB_COMMANDS = %w(list create resolve)
global_opts = Trollop::options do
  banner "issue.rb: lightweight issue management"
  opt :dry_run, "Don't actually do anything", :short => "-n"
  stop_on SUB_COMMANDS
end



cmd = ARGV.shift # get the subcommand
cmd ||= 'list'

cmd_opts = {}

if cmd == 'list'
  cmd_opts = 
    Trollop::options do
      opt :all, "list all issues"
      opt :newest, "list newest issues first"
      opt :oldest, "list oldest issues first"
      opt :verbose, "verbose list of issues", :short => 'v'
    end
elsif cmd == "create"
  cmd_opts = 
    Trollop::options do
      opt :bug, "create a bug", :short => 'b'
      opt :improvement, "create an improvement", :short => 'i'
      opt :task, "create a task", :short => 't'
    end
  cmd_opts[:title] = ARGV.shift || Trollop::die( "Please enter a title for the new issue!")
elsif cmd == "resolve"
  cmd_opts[:issue_id] = ARGV.shift || Trollop::die( "Please enter a title for the new issue!")
    
else
  Trollop::die "unknown command #{cmd.inspect}"
end


#======================================================================================================================#
#                                                         Main
#======================================================================================================================#

Issues = FileTest.exists?(DATABASE_NAME) && YAML.load_file(DATABASE_NAME) || []

case cmd
  when "create" 
    create_issue(cmd_opts, Issues)
  when "list" 
    list_issues(cmd_opts, Issues)
  when "resolve" 
    resolve_issues(cmd_opts, Issues)
end


if cmd != "list"
  FileTest.exists?('.issues') || Dir.mkdir('.issues')
  File.open(DATABASE_NAME, 'w' ) { |out| YAML.dump(Issues, out) }
end


#======================================================================================================================#

