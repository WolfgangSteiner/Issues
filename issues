#!/usr/bin/env ruby
# encoding: utf-8 
#======================================================================================================================#

require 'rubygems'
require 'fattr'
require 'SecureRandom'
require 'trollop'
require 'terminfo'
require 'tempfile'
require 'yaml'

#YAML::ENGINE.yamler = 'psych'

#======================================================================================================================#

def terminal_width
  TermInfo.screen_size[1]
end


#----------------------------------------------------------------------------------------------------------------------#

def separator(char='=')
  '#' + (char * (terminal_width - 2)) + '#'
end  


#----------------------------------------------------------------------------------------------------------------------#

def small_separator
  separator ('-')
end  


#----------------------------------------------------------------------------------------------------------------------#

def comment(comment)
  pad_string("\# #{comment}", "#", terminal_width)
end


#----------------------------------------------------------------------------------------------------------------------#

def pad_string(a_string, a_suffix, a_width)
  a_suffix.length ? a_string + " " * (a_width - a_string.length - a_suffix.length) + a_suffix : a_string.dup
end


#======================================================================================================================#

class Issue
  fattr :id, :date, :type, :title, :description, :status


#----------------------------------------------------------------------------------------------------------------------#  

  def self.createNewIssue(title, type="bug")
    newIssue = Issue.new
    newIssue.id = SecureRandom.hex.force_encoding("UTF-8")
    newIssue.date = Time.new
    newIssue.title = title
    newIssue.status = "open"
    newIssue.type = type
    newIssue
  end


#----------------------------------------------------------------------------------------------------------------------#  

  def copy_from(a_issue)
    self.class.fattrs.each do |a|
      a_issue.send(a) && self.send(a, a_issue.send(a).dup)
    end
  end  
      
#----------------------------------------------------------------------------------------------------------------------#  
  
  def format_title(prefix, only_first_line_prefix=false, suffix='')
    the_suffix = suffix.length ? " " + suffix : ""
    text_width = terminal_width - 1 - the_suffix.length
    title_array = @title.split(" ")
    result = []
    current_line = prefix.dup
    current_prefix = only_first_line_prefix && " " * prefix.length || prefix.dup
    
    title_array.each do |w|
      (current_line.length + w.length + 1 > text_width) \
        && result << pad_string(current_line, suffix, terminal_width) \
        && current_line = current_prefix.dup
      current_line << " " << w
    end
    
    current_line.length > current_prefix.length && result << pad_string(current_line, suffix, terminal_width)
    result.join("\n")
  end


#----------------------------------------------------------------------------------------------------------------------#  
  
  def format_verbose
    puts separator
    puts comment("#{@id[0,6]} #{@date.to_s[0,10]} #{@type.capitalize} (#{@status})")
    puts format_title("#", false, "#")
    
    if @description
      puts small_separator
      
      @description.split("\n").each do |l|
        puts pad_string("# #{l}", "#", terminal_width)
      end
    end
    
    puts separator
    puts
    puts
  end


#----------------------------------------------------------------------------------------------------------------------#

  def format_list
    puts format_title("#{short_id} (#{@type[0,1].capitalize})", true)
  end


#----------------------------------------------------------------------------------------------------------------------#  

  def edit_description
    file = Tempfile.new('issues')
    file.write(@description)
    file.close
    system("$EDITOR #{file.path}")

    file.open
    new_description = file.read

    puts new_description

    if new_description != @description
      @description = new_description.dup
      return true
    end
    
    return false
  end

#----------------------------------------------------------------------------------------------------------------------#  

  def edit_all
    edit_file = file = Tempfile.new('issues')
    file.write(self.to_yaml)
    file.close
    
    system("$EDITOR #{file.path}")

    file.open
    
    if (file.read != self.to_yaml)
      new_issue = YAML::load_file(file.path)
      self.copy_from(new_issue)
      return true
    end 
    
    return false
  end


#----------------------------------------------------------------------------------------------------------------------#  

  def short_id
    @id[0,6]
  end
    
end


#======================================================================================================================#
#                                                   Main Program Logic
#======================================================================================================================#

class IssuesDb
  fattr :issues_array
  
#----------------------------------------------------------------------------------------------------------------------#

  def initialize(database_file)
    @database_file = database_file
    @issues_array = FileTest.exists?(database_file) && YAML.load_file(database_file) || []
  end
  

#----------------------------------------------------------------------------------------------------------------------#

  def select_issues(&select_proc)
    return @issues_array.select(&select_proc)
  end
  

#----------------------------------------------------------------------------------------------------------------------#

  def select_issue(&select_proc)
    result = select_issues(&select_proc)
    
    if result.count == 1
      return result[0]
  
    elsif result.count > 1
      puts "Found more than one issue that match this query:"
      result.each{|i| puts("#{i.id} #{i.title}")}
      exit
    
    else
      puts "Error: No issue found for query."
      exit
    end

    nil
  end  


#----------------------------------------------------------------------------------------------------------------------#

  def has_issue(issue_id)
    @issues_array.any? { |issue| issue.id.start_with?(issue_id) }
  end
  

#----------------------------------------------------------------------------------------------------------------------#

  def save_db()
    FileTest.exists?('.issues') || Dir.mkdir('.issues')
    File.open(@database_file, 'w' ) { |out| YAML.dump(@issues_array, out) }
  end
  

#----------------------------------------------------------------------------------------------------------------------#

  def determine_issue_type(opts)
    issue_types = %w{bug improvement task}
    issue_type = nil
    issue_types.each { |t| opts[t.to_sym] == true && issue_type = t }
    
    issue_type && (return issue_type)

    case opts[:title]
    when /\b(improve|implement)/i
      "improvement"
    when /\b(fix|bug|crash)/i
      "bug"
    else
      "task"
    end
  end


#----------------------------------------------------------------------------------------------------------------------#

  def create_issue(opts)
    type = determine_issue_type(opts)
    new_issue = Issue.createNewIssue(opts[:title], type)
    @issues_array << new_issue
    save_db()  
    puts "Created issue #{new_issue.short_id} #{new_issue.title}"
  end


#----------------------------------------------------------------------------------------------------------------------#

  def list_issues(opts)
    if opts[:issue_id]
      list_issue(opts[:issue_id])
    else
      list_proc = opts[:verbose] ? "format_verbose" : "format_list"

      issue_types = %w{bug improvement task}
      did_select_issue_types = opts.any? { |key,value| issue_types.include?(key.to_s.chomp('s')) && value == true }
      did_select_issue_types && issue_types.delete_if { |issue_type| opts["#{issue_type}s".to_sym] == false }
      
      issues = @issues_array.select { |issue| issue.status == 'open' && issue_types.include?(issue.type) } 
      issues.each {|issue| issue.method(list_proc).call}
    end
  end


#----------------------------------------------------------------------------------------------------------------------#

  def list_issue(issue_id)
    issue = select_issue {|i| i.id.start_with?(issue_id) }
    issue.format_verbose()
  end


#----------------------------------------------------------------------------------------------------------------------#

  def resolve_issues(opts)
    issue_id = opts[:issue_id]
    resolved_issue = select_issue{|i| i.id.start_with?(issue_id) && i.status == "open"}

    status, message = (opts[:cmd] == "resolve") ? ["resolved", "Resolved"] : ["wontfix", "Won't fix"]

    resolved_issue.status = status
    message = "#{message} issue #{resolved_issue.short_id} #{resolved_issue.title}"
    puts message

    save_db()
    opts[:commit] && exec("git commit -a -m \"#{message}\"")
  end


#----------------------------------------------------------------------------------------------------------------------#

  def edit_issue(opts)
    issue_id = opts[:issue_id]
    issue = select_issue { |i| i.id.start_with?(issue_id) } 
  
    did_change_issue = false
  
    if (opts[:description])
      did_change_issue = issue.edit_description
    else
      did_change_issue = issue.edit_all
    end
   
    did_change_issue && save_db()
  end


#----------------------------------------------------------------------------------------------------------------------#

  def set_type(opts)
    opts[:issue_ids].each do | issue_id|
      issue = select_issue { |i| i.id.start_with?(issue_id) }
      issue.type = opts[:new_type]
      issue.format_list
    end
    
    save_db()
  end


#----------------------------------------------------------------------------------------------------------------------#


end


#======================================================================================================================#
# Command Line Parsing
#======================================================================================================================#

EXECUTABLE_NAME=File.basename($0)
DATABASE_NAME= ".issues/" << EXECUTABLE_NAME << ".yaml"

SUB_COMMANDS = %w(list create resolve wontfix edit)
global_opts = Trollop::options do
  banner "issue.rb: lightweight issue management"
  opt :dry_run, "Don't actually do anything", :short => "-n"
  stop_on SUB_COMMANDS
end



cmd = ARGV.shift # get the subcommand
cmd ||= 'list'

cmd_opts = {}

if cmd == 'list'
  cmd_opts = 
    Trollop::options do
      opt :all, "list all issues"
      opt :newest, "list newest issues first"
      opt :oldest, "list oldest issues first"
      opt :verbose, "verbose list of issues", :short => 'v'
      opt :bugs, "list bugs",                 :short => 'b'
      opt :improvements, "list improvements", :short => 'i'
      opt :tasks, "list tasks",               :short => 't'
    end
    
    ARGV && cmd_opts[:issue_id] = ARGV.shift 

elsif cmd == "create"
  cmd_opts = 
    Trollop::options do
      opt :bug, "create a bug", :short => 'b'
      opt :improvement, "create an improvement", :short => 'i'
      opt :task, "create a task", :short => 't'
    end
  cmd_opts[:title] = ARGV.shift || Trollop::die( "Please enter a title for the new issue!")

elsif cmd == "resolve" || cmd == "wontfix"
  cmd_opts = 
    Trollop::options do
      opt :commit, "do a git commit", :short => 'c'
    end  
  cmd_opts[:issue_id] = ARGV.shift || Trollop::die( "Please enter an issue id!")

elsif cmd == "edit"
  cmd_opts = 
    Trollop::options do
      opt :description, "edit the issue description", :short => 'd'
      opt :todos, "edit the issue todo list", :short => 't'
    end      
  cmd_opts[:issue_id] = ARGV.shift || Trollop::die( "Please enter an issue id!")

elsif cmd == "set-type"
  new_type = ARGV.shift
  %w{bug improvement task}.include?(new_type) || Trollop::die("Please specify one of [bug, improvement, task] as new issue type")
  cmd_opts[:new_type] = new_type
  ARGV.count > 0 && ARGV.all? { |id| /\h{1,32}$/ =~ id } || Trollop::die( "Please enter an issue id!")
  cmd_opts[:issue_ids] = ARGV.dup
else
  Trollop::die "unknown command #{cmd.inspect}"
end


cmd_opts[:cmd] = cmd 


#======================================================================================================================#
#                                                         Main
#======================================================================================================================#

Issues = IssuesDb.new(DATABASE_NAME)

case cmd
  when "create" 
    Issues.create_issue(cmd_opts)
  when "list" 
    Issues.list_issues(cmd_opts)
  when "resolve", "wontfix"
    Issues.resolve_issues(cmd_opts)
  when "edit"
    Issues.edit_issue(cmd_opts)
  when "set-type"
    Issues.set_type(cmd_opts)
end


#======================================================================================================================#

